package ClassC::Plugin::Writer::Header;

use v5.38;
use ClassC::Core::Logging::Logger;
use ClassC::Plugin::Parser::Util;
require ClassC::Core::OOP::Dependency;

my $logger = ClassC::Core::Logging::Logger->new(level => TRACE);

sub write_header {
  my ($file, $class) = @_;
  $logger->debug("Writing $file");
  my $output;
  eval {
    open $output, ">$file";
    local *STDOUT = $output;
    __write_class($class);
  };
  close $output if $output;
}

sub __write_class {
  my ($class)     = @_;
  my $class_name  = $class->{name};
  my $vtable_name = "${class_name}_Vtable_";
  my @args        = ($class, $class_name, $vtable_name);
  $logger->trace("> Writing class header");
  __write_title(@args);
  __write_includes(@args);
  __write_typedefs(@args);
  __write_vtable_struct(@args);
  __write_instance_struct(@args);
  __write_functions(@args);
  __write_vtable_instance(@args);
}

sub __write_title {
  my ($class, $class_name) = @_;
  $logger->trace(">> Writing title");
  print <<~EOF
      /*
       * Class $class_name
       * Generated by ClassC.
       */
      EOF
}

sub __write_includes {
  $logger->trace(">> Writing includes");
  my ($class) = @_;
  my @dependencies = @{ $class->{dependencies} };
  if (scalar @dependencies > 0) {
    say '';
  }
  for my $dependency (@dependencies) {
    if ($dependency->{id} == ClassC::Core::OOP::Dependency::SYSTEM()) {
      say "#include <$dependency->{dependency}>";
    } elsif ($dependency->{id} == ClassC::Core::OOP::Dependency::USER()) {
      say "#include \"$dependency->{dependency}\"";
    }
  }
}

sub __write_typedefs {
  $logger->trace(">> Writing typedefs");
  my ($class, $class_name) = @_;
  say "\ntypedef struct $class_name $class_name;";
}

sub __write_vtable_struct {
  $logger->trace(">> Writing vtable struct");
  my ($class, $class_name, $vtable_name) = @_;
  say "\n/* Vtable */";
  say "struct $vtable_name {";
  __write_methods($class);
  say "};";
}

sub __write_instance_struct {
  $logger->trace(">> Writing instance struct");
  my ($class, $class_name, $vtable_name) = @_;
  say "\n/* Instance */";
  say "struct $class_name {";
  say "  struct $vtable_name* _vtable_;";
  __write_fields($class);
  say "};";
}

sub __write_fields {
  $logger->trace(">>> Writing fields");
  my ($class) = @_;
  for my $field (@{ $class->{fields} }) {
    my $type = $field->{type};
    if (ends_with($type, ' *')) {
      say "  $type$field->{name};";
    } else {
      say "  $type $field->{name};";
    }
  }
}

sub __write_methods {
  $logger->trace(">>> Writing methods");
  my ($class) = @_;
  for my $method (@{ $class->{methods} }) {
    my $return_type = $method->{return_type};
    if (ends_with($return_type, ' *')) {
      say "  $method->{return_type}(*$method->{name})($method->{arguments});";
    } else {
      say "  $method->{return_type} (*$method->{name})($method->{arguments});";
    }
  }
}

sub __write_functions {
  $logger->trace(">> Writing functions");
  my ($class, $class_name) = @_;
  say "\n/* Functions */";
  for my $method (@{ $class->{methods} }) {
    my $return_type   = $method->{return_type};
    my $function_name = "${class_name}_$method->{name}";
    if (ends_with($return_type, ' *')) {
      say "$method->{return_type}$function_name($method->{arguments});";
    } else {
      say "$method->{return_type} $function_name($method->{arguments});";
    }
  }
}

sub __write_vtable_instance {
  $logger->trace(">> Writing vtable instance");
  my ($class, $class_name, $vtable_name) = @_;
  my $vtable_instance_name = "${class_name}_vtable_";
  say "\n/* Vtable Instance */";
  say "const struct $vtable_name $vtable_instance_name = {";
  for my $method (@{ $class->{methods} }) {
    my $function_name = "${class_name}_$method->{name}";
    say "  .$method->{name} = $function_name,";
  }
  say '};';
}

1;
